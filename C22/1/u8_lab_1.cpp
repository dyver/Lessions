#define nop ("nop");

//Практика 1:
// enum class
// initializer_list и универсальные списки инициализации
// auto
// decltype
// lambda functions

#include <vector>
#include <map>
#include <set>
#include <list>
#include <algorithm>
#include <cmath>

#include <u8_lab_1.h>

using namespace std;

void outHeader(const char* taskName) {
    cout << endl << "+++++ Задание №" << taskName << "." << endl << endl;
}

int main() {

    //Задание 1.
    {
        outHeader("1");
        enum class months : char { January, February, March/*...*/ };
        enum class weekDays { Monday, Tuesday /*...*/ };

        months m = months::January;
        //а) уберите проблемы
//         if (m == weekDays::Monday) { /*...*/ }
        if (m == months::February) { /*...*/ }
        //б) оптимизируйте использование памяти
        months year[] = { months::January, months::February, months::March };
        size_t n = sizeof(year); //???
        cout << n << endl;
    }

    //////////////////////////////////////////////////////////////////////////////////
    //Задание 2. Создайте и с помощью списка инициализации заполните значениями вектор с
    //элементами - string
    //С помощью range-based for преобразуйте все буквы в верхний регистр
    //а остальные символы должны остаться неизменными
    {
        vector<string> v{ "Hello", ",", "World!" };
        for (auto& str : v) {
            for (auto& ch : str) {
                if (isalpha(ch)) {
                    ch = toupper(ch);
                }
            }
        }
        outHeader("2");
        for (const auto& str : v) {
            cout << str << endl;
        }
        __asm nop

    }
    /////////////////////////////////////////////////////////////////////
    ///Задание 3. Создайте и с помощью списка инициализации заполните значениями
    //map таким образом, чтобы он содержал в качестве ключа букву, а в качестве значения
    //отсортированную по алфавиту совокупность слов (string), начинающихся с этой буквы

    //С помощью range-based for распечатайте содержимое, например: A: any, apple, away
    {
        outHeader("3");
        map<char, set<string>> collection{
            { 'B', { "boost"s, "beta"s } },
            { 'A' , { "argument"s, "alpha"s } }
        };
        for (const auto& el : collection) {
            cout << el.first << ": ";
            stringstream ss;
            for (const auto& str : el.second) {
                ss << str << ", ";
            }
            auto out{ss.str()};
            out.erase(end(out) - 2, end(out));
            cout << out << endl;
        }
        __asm nop
    }
    /////////////////////////////////////////////////////////////////////
    ///Задание 4. создать функцию для вывода на печать элементов последовательностей, заданных ниже

    {
        outHeader("4");
        std::vector<double> vd = { 1.1,2.2,3.3 };
        PrintAnyCont(vd);

        std::string s("abc");
        PrintAnyCont(s);

        int ar[] = { 1, 2, 3 };
        PrintAnyCont(ar);

        std::initializer_list<int> il{ 3,4,5 };
        PrintAnyCont(il);

        __asm nop
    }

    /////////////////////////////////////////////////////////////////////
    ///Задание 5.
    //создать функцию для "отрицания" значений, например:
    // было: {1, -2, 5}, стало: {-1, 2, -5})
    // изменение объектов типа std::string может выглядеть "aBc1" -> "AbC1"
    //элементов последовательностей, заданных ниже:

    {
        outHeader("5");
        std::vector<double> vd{ 1.1,2.2,3.3 };
        NegateAll(vd);
        PrintAnyCont(vd);

        std::list<std::string> ls{ "aBc", "Qwerty", "n12" };
        NegateAll(ls);
        PrintAnyCont(ls);

        int ar[]{ 1, 2, 3 };
        NegateAll(ar);
        PrintAnyCont(ar);
        __asm nop
    }

    ///Задание 4а. создать функцию для инкремента элементов последовательностей, заданных ниже
    {
        outHeader("4a");
        std::vector<double> vd = { 1.1, 2.2, 3.3 };
        IncAnyCont(vd);
        PrintAnyCont(vd);

        int ar[] = { 1, 2, 3 };
        IncAnyCont(ar);
        PrintAnyCont(ar);

        std::string s("123");
        IncAnyCont(s);
        PrintAnyCont(ar);
        __asm nop
    }

    //////////////////////////////////////////////////////////////////////////////////
    //Задание 5. Реализовать функцию сортировки по модулю элементов последовательностей, заданных ниже
    //Собственно для сортировки можно использовать обобщенный алгоритм sort(),
    //а для задания условия - лямбда-функцию
    {
        outHeader("5");
        std::vector<double> vd = { -3.3,  2.2, -1.1 };
        absSort(vd);
        PrintAnyCont(vd);

        int ar[] = { -3, 2, -1 };
        absSort(ar);
        PrintAnyCont(ar);
        __asm nop
    }

    //////////////////////////////////////////////////////////////////////////////////
    //Задание 6.
    //напишите функцию, которая будет формировать и возвращать вектор, каждый элемент
    //которого является суммой элементов двух последовательностей
    //РАЗНОЙ длины и с элементами РАЗНОГО типа.

    //Подсказка 1: так как последовательности могут быть разной длины, логично
    //сделать размер результирующего вектора максимальным из двух

    //Подсказка 2: подумайте о возможности использования алгоритма transform(),
    //в котором трансформирующее действие удобно в свою очередь задавать лямбда-функцией

    //например:
    {
        outHeader("6");
        std::vector<int> v{ 1,2,3,4 };
        std::list<double> l{ 1.1, 2.2, 3.3, 4.4, 5.5 };

        auto res1 = SumCont(v, l);
        PrintAnyCont(res1);

        std::list<int> ll{ 1, 2, 3, 4, 5, 6, 7, 8 };
        double ar[] = { 1.1, 2.2, 3.3, 4.4, 5.5 };
        auto res2 = SumCont(ar, ll);
        PrintAnyCont(res2);
        __asm nop
    }

    //////////////////////////////////////////////////////////////////////////////////
    //Задание 7. Реализуйте функцию, которая принимает следующие парметры:
    //сформированную последовательность любого типа с элементами любого типа,
    //два (пустых) контейнера любого типа из vector, list, deque, set с элементами того же
    //типа, что и у сформированной последовательности

    //Функция должна "разложить" значения заданной последовательности в два пустых контейнера
    //согласно заданному условию. Условие задать лябда-функцией
    //Исходная последовательность при этом не меняется
    {
        outHeader("7");
        //Например:
        std::vector<int> v{ 1,2,3,4,5 };
        std::set<int> l; //сюда четные
        std::list<int> d; //а сюда нечетные
//         std::deque<int> d; //а сюда нечетные
//         std::set<int> d; //а сюда нечетные
        Separate(v, l, d, [](const auto& a) { return not (a & 1); } );
        PrintAnyCont(v);
        PrintAnyCont(l);
        PrintAnyCont(d);

        __asm nop
    }

    //////////////////////////////////////////////////////////////////////////////////
    //Задание 8. C помощью алгоритма for_each()!!! (а не count_if()) посчитать сколько
    //букв в верхнем регистре
    //  Использовать лямбда функцию
    {
        outHeader("8");
        char s[] = "Hello World!";
        int res = 0;
        for_each(cbegin(s), cend(s), [&res](char c) { if (isupper(c)) ++res; });
        cout << res << endl;
    }

    //////////////////////////////////////////////////////////////////////////////////
    //Задание 9a. Создайте класс, который должен быть "оберткой" для вектора с УНИКАЛЬНЫМИ значениями
    //любого типа.
    //Для хранения элементов используйте std::vector

    //Реализуйте конструктор, который может принимать любое количество значений (значения могут повторяться)
    //Реализуйте метод добавления любого количества значений (значения могут повторяться)
    //Реализуйте метод удаления любого количества значений (значения могут повторяться)
    //Реализуйте метод сортировки, который будет принимать в качестве параметра признак по возрастанию / по убыванию
    {
        outHeader("9a and b");
        Container<int> c({ 1, 2, 3, 3, 10 }, 0, 10);
        PrintAnyCont(c);
        c = { 4, 5, 6, 5, 10};
        PrintAnyCont(c);
        c.remove({6});
        PrintAnyCont(c);
        c.sort(true);
        PrintAnyCont(c);
        c.sort(false);
        PrintAnyCont(c);
        Container<string> s({ "a"s, "b"s, "b"s, "g"s }, "a"s, "e"s);
        PrintAnyCont(s);
    }

    //Задание 9b. Модифицируйте класс из предыдущего задания (или создайте новый) таким образом,
    //чтобы значения не только были бы уникальными, но и находились в заданном диапазоне.
    //Замечание: такой класс в общем виде (для любых данных) смысла, наверно, не имеет, но его можно
    //использовать для таких типов данных, как целых, плавающих и тех пользовательских, для которых
    //имеют смысл операции сравнения (больше, меньше)
    //Подумайте: какие данные нужно добавить в класс и какие методы нужно модифицировать

    //////////////////////////////////////////////////////////////////////////////////
    //Задание 10*. Реализовать конвертацию enum в строковое представление  - enumToString
    // и наоборот - stringToEnum

    //Подсказки:
    //
    //1. Соответствующие именованным константам строки все равно нужно где-то хранить =>
    //1.1 Именованные константы в перечислении должны быть уникальными => соответствующие строки
    //тоже должны быть уникальными, => уникальные строки могут быть использованы в качестве
    //ключа в std::map

    //1.2 а вот значения (соответствующие именованым константам)
    //могут быть любыми и даже могут повторяться (упрощаем задачу, считая, что значения НЕ повторяются)
    //=> подходит контейнер std::map<string,<значение> >

    //1.3 Согласно стандарту С++11 переменные перечислимого типа могут быть разного размера и типа,
    //а хотелось бы обеспечить универсальную конвертацию

    //
    //2. Так как типы перечислений разные, то enumToString и stringToEnum должны быть шаблонными
    //2.1 Пользователь может ошибиться или злонамеренно передать в функции значения, которым
    //   ничего не соответствует => защита!
    //2.2 В функциях enumToString и stringToEnum (в зависимости от типа перечисления) нужно будет
    //   анализировать соответствующий используемому типу перечисления контейнер

    {
        outHeader("10*");
    //Например:

        enum COLORS { red = 1, green = 2, blue = 4 };
        registerEnum<COLORS>({
            { "red", COLORS::red },
            { "green", COLORS::green },
            { "blue" , COLORS::blue }
        });

        COLORS c1{COLORS::red};
        try {
            // Нормальное преобразование
            c1 = stringToEnum<COLORS>("blue");
            cout << "COLORS::blue = " << static_cast<EnumElementType<COLORS>>(c1) << endl;
            // Опечатка
            c1 = stringToEnum<COLORS>("blye");
        } catch (const exception& e) {
            cerr << "ERROR: " << e.what() << endl;
        }

        try {
            // Нормальное преобразование
            auto str1 = enumToString(c1);
            cout << "COLORS::blue has name " << str1 << endl;
            // Попытка обмана
            auto str2 = enumToString(static_cast<COLORS>(10));
            cout << str2 << endl;
        } catch (const exception& e) {
            cerr << "ERROR: " << e.what() << endl;
        }
    }
}
